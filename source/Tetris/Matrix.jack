class Matrix {
    field Array lockedCells, activeCells, targetCells, ROTATIONS, KICKS;
    field int WIDTH, HEIGHT, location, activeType,
            orientation, targetOrientation;

    constructor Matrix new() {
        let WIDTH = 10;
        let HEIGHT = 40;
        let lockedCells = Array.new(WIDTH * HEIGHT);
        let activeCells = Array.new(4);
        let targetCells = Array.new(4);

        do initRotations();
        return this;
    }

    /** Set up the table of rotations.
     *
     * Each Tetrimino type has 4 possible orientations, beginning with the
     * spawn orientation at 0 and rotating clockwise 90 degrees through to
     * orientation 3. Each orientation consists of 4 grid locations, relative
     * to the top-left corner of the piece's bounding box.
     */
    method void initRotations() {
        let ROTATIONS = Array.new(7 * 4 * 4);
        /* O-type -- all orientations are the same
         *
         * .##.
         * .##.
         */
        let ROTATIONS[0] = 1;
        let ROTATIONS[1] = 2;
        let ROTATIONS[2] = -9;
        let ROTATIONS[3] = -8;

        let ROTATIONS[4] = 1;
        let ROTATIONS[5] = 2;
        let ROTATIONS[6] = -9;
        let ROTATIONS[7] = -8;

        let ROTATIONS[8] = 1;
        let ROTATIONS[9] = 2;
        let ROTATIONS[10] = -9;
        let ROTATIONS[11] = -8;

        let ROTATIONS[12] = 1;
        let ROTATIONS[13] = 2;
        let ROTATIONS[14] = -9;
        let ROTATIONS[15] = -8;

        /* I-type
         *
         * ....  ..#.  ....  .#..
         * ####  ..#.  ....  .#..
         * ....  ..#.  ####  .#..
         * ....  ..#.  ....  .#..
         */
        let ROTATIONS[16] = -10;
        let ROTATIONS[17] = -9;
        let ROTATIONS[18] = -8;
        let ROTATIONS[19] = -7;

        let ROTATIONS[20] = 2;
        let ROTATIONS[21] = -8;
        let ROTATIONS[22] = -18;
        let ROTATIONS[23] = -28;

        let ROTATIONS[24] = -20;
        let ROTATIONS[25] = -19;
        let ROTATIONS[26] = -18;
        let ROTATIONS[27] = -17;

        let ROTATIONS[28] = 1;
        let ROTATIONS[29] = -9;
        let ROTATIONS[30] = -19;
        let ROTATIONS[31] = -29;

        /* T-type
         *
         * .#.  .#.  ...  .#.
         * ###  .##  ###  ##.
         * ...  .#.  .#.  .#.
         */
        let ROTATIONS[32] = 1;
        let ROTATIONS[33] = -10;
        let ROTATIONS[34] = -9;
        let ROTATIONS[35] = -8;

        let ROTATIONS[36] = 1;
        let ROTATIONS[37] = -9;
        let ROTATIONS[38] = -8;
        let ROTATIONS[39] = -19;

        let ROTATIONS[40] = -10;
        let ROTATIONS[41] = -9;
        let ROTATIONS[42] = -8;
        let ROTATIONS[43] = -19;

        let ROTATIONS[44] = 1;
        let ROTATIONS[45] = -10;
        let ROTATIONS[46] = -9;
        let ROTATIONS[47] = -19;

        /* L-type
         *
         * ..#  .#.  ...  ##.
         * ###  .#.  ###  .#.
         * ...  .##  #..  .#.
         */
        let ROTATIONS[48] = 2;
        let ROTATIONS[49] = -10;
        let ROTATIONS[50] = -9;
        let ROTATIONS[51] = -8;

        let ROTATIONS[52] = 1;
        let ROTATIONS[53] = -9;
        let ROTATIONS[54] = -19;
        let ROTATIONS[55] = -18;

        let ROTATIONS[56] = -10;
        let ROTATIONS[57] = -9;
        let ROTATIONS[58] = -8;
        let ROTATIONS[59] = -20;

        let ROTATIONS[60] = 0;
        let ROTATIONS[61] = 1;
        let ROTATIONS[62] = -9;
        let ROTATIONS[63] = -19;

        /* J-type
         *
         * #..  .##  ...  .#.
         * ###  .#.  ###  .#.
         * ...  .#.  ..#  ##.
         */
        let ROTATIONS[64] = 0;
        let ROTATIONS[65] = -10;
        let ROTATIONS[66] = -9;
        let ROTATIONS[67] = -8;

        let ROTATIONS[68] = 1;
        let ROTATIONS[69] = 2;
        let ROTATIONS[70] = -9;
        let ROTATIONS[71] = -19;

        let ROTATIONS[72] = -10;
        let ROTATIONS[73] = -9;
        let ROTATIONS[74] = -8;
        let ROTATIONS[75] = -18;

        let ROTATIONS[76] = 1;
        let ROTATIONS[77] = -9;
        let ROTATIONS[78] = -20;
        let ROTATIONS[79] = -19;

        /* S-type
         *
         * .##  .#.  ...  #..
         * ##.  .##  .##  ##.
         * ...  ..#  ##.  .#.
         */
        let ROTATIONS[80] = 1;
        let ROTATIONS[81] = 2;
        let ROTATIONS[82] = -10;
        let ROTATIONS[83] = -9;

        let ROTATIONS[84] = 1;
        let ROTATIONS[85] = -9;
        let ROTATIONS[86] = -8;
        let ROTATIONS[87] = -18;

        let ROTATIONS[88] = -9;
        let ROTATIONS[89] = -8;
        let ROTATIONS[90] = -20;
        let ROTATIONS[91] = -19;

        let ROTATIONS[92] = 0;
        let ROTATIONS[93] = -10;
        let ROTATIONS[94] = -9;
        let ROTATIONS[95] = -19;

        /* Z-type
         *
         * ##.  ..#  ...  .#.
         * .##  .##  ##.  ##.
         * ...  .#.  .##  #..
         */
        let ROTATIONS[96] = 0;
        let ROTATIONS[97] = 1;
        let ROTATIONS[98] = -9;
        let ROTATIONS[99] = -8;

        let ROTATIONS[100] = 2;
        let ROTATIONS[101] = -9;
        let ROTATIONS[102] = -8;
        let ROTATIONS[103] = -19;

        let ROTATIONS[104] = -10;
        let ROTATIONS[105] = -9;
        let ROTATIONS[106] = -19;
        let ROTATIONS[107] = -18;

        let ROTATIONS[108] = 1;
        let ROTATIONS[109] = -10;
        let ROTATIONS[110] = -9;
        let ROTATIONS[111] = -20;

        return;
    }

    /** Translate a (row, col) cell reference to an internal array index. */
    method int cellRefToIndex(int row, int column) {
        return (row * WIDTH) + column;
    }

    method int getActiveType() {
        return activeType;
    }

    method Array getActiveCells() {
        return activeCells;
    }

    /** Add a new Tetrimino to the matrix and return whether successful.
     *
     * If there are any existing blocks intersecting with the spawn position of
     * the new piece, then it is a Block Out game over condition -- do nothing
     * and return false.
     *
     * Otherwise, add the new piece to the matrix, make it the active piece,
     * and return true.
     */
    method boolean addPiece(int type) {
        var int i, base;
        let base = 214;

        // The spawn position is shifted 1 column left for O and I types.
        if ((type = 1) | (type = 2)) {
            let base = base - 1;
        }

        /* Determine where the new minos should spawn and record these
         * positions in targetCells. New pieces always spawn with orientation
         * 0.
         */
        let i = (type - 1) * 16;
        let activeCells[0] = base + ROTATIONS[i];
        let activeCells[1] = base + ROTATIONS[i + 1];
        let activeCells[2] = base + ROTATIONS[i + 2];
        let activeCells[3] = base + ROTATIONS[i + 3];

        // Now we know where it should spawn, check for collisions.
        if (~(isClear(
                activeCells[0], activeCells[1],
                activeCells[2], activeCells[3]))) {
            // Block Out condition: Game Over
            return false;
        }

        // The Tetrimino is clear to spawn, do it.
        let location = base;
        let activeType = type;
        let orientation = 0;
        return true;
    }

    /** Return whether all the given indexes are empty. */
    method boolean isClear(int a, int b, int c, int d) {
        return (
                (lockedCells[a] = 0) &
                (lockedCells[b] = 0) &
                (lockedCells[c] = 0) &
                (lockedCells[d] = 0));
    }

    /** Return whether the active piece has space to move. */
    method boolean canMove(int v) {
        return isClear(
                activeCells[0] + v,
                activeCells[1] + v,
                activeCells[2] + v,
                activeCells[3] + v);
    }

    /** Return whether the active piece has space to move left. */
    method boolean canMoveLeft() {
        // Check that none of the minos are up against the left wall.
        if (
                (Util.mod(activeCells[0], WIDTH) = 0) |
                (Util.mod(activeCells[1], WIDTH) = 0) |
                (Util.mod(activeCells[2], WIDTH) = 0) |
                (Util.mod(activeCells[3], WIDTH) = 0)) {
            return false;
        }
        return canMove(-1);
    }

    /** Return whether the active piece has space to move right. */
    method boolean canMoveRight() {
        // Check that none of the minos are up against the right wall.
        var int wall;
        let wall = WIDTH - 1;
        if (
                (Util.mod(activeCells[0], WIDTH) = wall) |
                (Util.mod(activeCells[1], WIDTH) = wall) |
                (Util.mod(activeCells[2], WIDTH) = wall) |
                (Util.mod(activeCells[3], WIDTH) = wall)) {
            return false;
        }
        return canMove(-1);
    }

    /** Return whether the active piece has space to drop down. */
    method boolean canDrop() {
        // Check that none of the blocks are on the floor.
        if (
                (activeCells[0] < WIDTH) |
                (activeCells[1] < WIDTH) |
                (activeCells[2] < WIDTH) |
                (activeCells[3] < WIDTH)) {
            return false;
        }
        return canMove(-10);
    }

    /** Return whether the active piece has space to rotate.
     *
     * We first check whether the piece can be rotated in-place. If not, we
     * then check a series of 4 alternative "kick" positions. The first valid
     * position is selected, and recorded internally.
     *
     * If no valid position is found, return false.
     */
    method boolean prepareRotate(boolean clockwise) {
        var int i;

        if (activeType = 1) {
            // O-Tetriminos do not rotate; do nothing and return false
            return false;
        }
        if (clockwise) {
            if (orientation = 3) {
                let targetOrientation = 0;
            } else {
                let targetOrientation = orientation + 1;
            }
        } else {
            if (orientation = 0) {
                let targetOrientation = 3;
            } else {
                let targetOrientation = orientation - 1;
            }
        }
        let i = ((activeType - 1) * 16) + (targetOrientation * 4);
        let targetCells[0] = location + ROTATIONS[i];
        let targetCells[1] = location + ROTATIONS[i + 1];
        let targetCells[2] = location + ROTATIONS[i + 2];
        let targetCells[3] = location + ROTATIONS[i + 3];

        return isClear(
                targetCells[0], targetCells[1],
                targetCells[2], targetCells[3]);
        // TODO: check whether rotation would hit a wall.

        return false;
    }

    /** Commit the rotation previously set up by canRotate(). */
    method void rotate() {
        let activeCells[0] = targetCells[0];
        let activeCells[1] = targetCells[1];
        let activeCells[2] = targetCells[2];
        let activeCells[3] = targetCells[3];
        let orientation = targetOrientation;
        return;
    }

    method void move(int v) {
        let activeCells[0] = activeCells[0] + v;
        let activeCells[1] = activeCells[1] + v;
        let activeCells[2] = activeCells[2] + v;
        let activeCells[3] = activeCells[3] + v;
        let location = location + v;
        return;
    }

    /** Drop the active piece down one row. */
    method void drop() {
        do move(-10);
        return;
    }

    /** Lock the active piece in place. */
    method void lock() {
        let lockedCells[activeCells[0]] = activeType;
        let lockedCells[activeCells[1]] = activeType;
        let lockedCells[activeCells[2]] = activeType;
        let lockedCells[activeCells[3]] = activeType;
        let activeType = 0;
        return;
    }

    method void dispose() {
        do activeCells.dispose();
        do targetCells.dispose();
        do lockedCells.dispose();
        do ROTATIONS.dispose();
        do Memory.deAlloc(this);
        return;
    }
}
