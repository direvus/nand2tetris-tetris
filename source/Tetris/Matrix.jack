class Matrix {
    field Array cells, activeCells;
    field int width, height, activeType;

    constructor Matrix new(int pWidth, int pHeight) {
        let width = pWidth;
        let height = pHeight;
        let cells = Array.new(width * height);
        let activeCells = Array.new(4);
        return this;
    }

    /** Translate a (row, col) cell reference to an internal array index. */
    method int cellRefToIndex(int row, int column) {
        return (row * width) + column;
    }

    method int getActiveType() {
        return activeType;
    }

    method Array getActiveCells() {
        return activeCells;
    }

    /** Add a new Tetrimino to the matrix and return whether successful.
     *
     * If there are any existing blocks intersecting with the spawn position of
     * the new piece, then it is a Block Out game over condition -- do nothing
     * and return false.
     *
     * Otherwise, add the new piece to the matrix, make it the active piece,
     * and return true.
     */
    method boolean addPiece(int type) {
        var int base;
        let base = 20 * width;

        /* Determine where the new Tetrimino should spawn and record these
         * positions in activeCells.
         */
        if (type = 1) { // O-type
            let activeCells[0] = base + 4;
            let activeCells[1] = base + 5;
            let activeCells[2] = base + width + 4;
            let activeCells[3] = base + width + 5;
        }

        if (type = 2) { // I-type
            let activeCells[0] = base + 3;
            let activeCells[1] = base + 4;
            let activeCells[2] = base + 5;
            let activeCells[3] = base + 6;
        }

        if (type = 3) { // T-type
            let activeCells[0] = base + 3;
            let activeCells[1] = base + 4;
            let activeCells[2] = base + 5;
            let activeCells[3] = base + width + 4;
        }

        if (type = 4) { // L-type
            let activeCells[0] = base + 3;
            let activeCells[1] = base + 4;
            let activeCells[2] = base + 5;
            let activeCells[3] = base + width + 5;
        }

        if (type = 5) { // J-type
            let activeCells[0] = base + 3;
            let activeCells[1] = base + 4;
            let activeCells[2] = base + 5;
            let activeCells[3] = base + width + 3;
        }

        if (type = 6) { // S-type
            let activeCells[0] = base + 3;
            let activeCells[1] = base + 4;
            let activeCells[2] = base + width + 4;
            let activeCells[3] = base + width + 5;
        }

        if (type = 7) { // Z-type
            let activeCells[0] = base + 4;
            let activeCells[1] = base + 5;
            let activeCells[2] = base + width + 3;
            let activeCells[3] = base + width + 4;
        }

        // Now we know where it should spawn, check for collisions.
        if (~(isClear(
                activeCells[0],
                activeCells[1],
                activeCells[2],
                activeCells[3]))) {
            // Block Out - game over
            return false;
        }

        // The Tetrimino is safe to spawn, set the activeType and return true.
        let activeType = type;
        return true;
    }

    /** Return whether all the given indexes are empty. */
    method boolean isClear(int a, int b, int c, int d) {
        return (
                (cells[a] = 0) &
                (cells[b] = 0) &
                (cells[c] = 0) &
                (cells[d] = 0));
    }

    /** Return whether the active piece has space to move. */
    method boolean canMove(int v) {
        return isClear(
                activeCells[0] + v,
                activeCells[1] + v,
                activeCells[2] + v,
                activeCells[3] + v);
    }

    /** Return whether the active piece has space to move left. */
    method boolean canMoveLeft() {
        // Check that none of the blocks are up against the left wall.
        if (
                (Util.mod(activeCells[0], width) = 0) |
                (Util.mod(activeCells[1], width) = 0) |
                (Util.mod(activeCells[2], width) = 0) |
                (Util.mod(activeCells[3], width) = 0)) {
            return false;
        }
        return canMove(-1);
    }

    /** Return whether the active piece has space to move right. */
    method boolean canMoveRight() {
        // Check that none of the blocks are up against the right wall.
        var int wall;
        let wall = width - 1;
        if (
                (Util.mod(activeCells[0], width) = wall) |
                (Util.mod(activeCells[1], width) = wall) |
                (Util.mod(activeCells[2], width) = wall) |
                (Util.mod(activeCells[3], width) = wall)) {
            return false;
        }
        return canMove(-1);
    }

    /** Return whether the active piece has space to drop down. */
    method boolean canDrop() {
        // Check that none of the blocks are on the floor.
        if (
                (activeCells[0] < width) |
                (activeCells[1] < width) |
                (activeCells[2] < width) |
                (activeCells[3] < width)) {
            return false;
        }
        return canMove(-10);
    }

    method void move(int v) {
        let activeCells[0] = activeCells[0] + v;
        let activeCells[1] = activeCells[1] + v;
        let activeCells[2] = activeCells[2] + v;
        let activeCells[3] = activeCells[3] + v;
        return;
    }

    /** Drop the active piece down one row. */
    method void drop() {
        do move(-10);
        return;
    }

    /** Lock the active piece in place. */
    method void lock() {
        let cells[activeCells[0]] = activeType;
        let cells[activeCells[1]] = activeType;
        let cells[activeCells[2]] = activeType;
        let cells[activeCells[3]] = activeType;
        let activeType = 0;
        return;
    }

    method void dispose() {
        do activeCells.dispose();
        do cells.dispose();
        do Memory.deAlloc(this);
        return;
    }
}
