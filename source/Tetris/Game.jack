class Game {
    field int left, top; // top-left coordinates of play area.
    field int width, height, maxRow; // dimensions of matrix grid.
    field int entropy;
    field Queue queue;
    field Matrix matrix;

    constructor Game new() {
        let left = 196;
        let top = 8;
        let width = 10;
        let height = 40;
        let maxRow = 19;
        do Random.init(1897);
        return this;
    }

    method void run() {
        var boolean exit;
        var char key;
        while (~exit) {
            do showTitleScreen();
            let key = recvKeyPress();

            if ((key = 81) | (key = 113)) { // Q or q
                let exit = true;
            }

            if (key = 32) { // Space
                do Random.addEntropy(entropy);
                // TODO do something with the score? Track a high score?
                do play();
            }
        }
        return;
    }

    /** Receive a single key press event.
     *
     * This method will continue to sample the keyboard until the user has
     * pressed a key and then released it. The function will then return the
     * scan code of the key that was pressed.
     *
     * Also collect the number of ticks spent waiting for the key press to
     * complete, which will be used to initialise the random number generator.
     */
    method char recvKeyPress() {
        var char key;
        while (key = 0) {
            let key = Keyboard.keyPressed();
            let entropy = entropy + 1;
            do Sys.wait(1);
        }

        while (~(Keyboard.keyPressed() = 0)) {
            let entropy = entropy + 1;
            do Sys.wait(1);
        }
        let entropy = entropy - key;
        return key;
    }

    method void showTitleScreen() {
        do Screen.clearScreen();
        do Logo.draw(166, 16);

        do Output.moveCursor(13, 1);
        do Output.printString("Tetris (c) 1985-2025 Tetris Holding. Tetris logos, Tetris");
        do Output.moveCursor(14, 1);
        do Output.printString("theme song and Tetriminos are trademarks of Tetris Holding. The");
        do Output.moveCursor(15, 1);
        do Output.printString("Tetris trade dress is owned by Tetris Holding. Licensed to The");
        do Output.moveCursor(16, 1);
        do Output.printString("Tetris Company. Tetris Game Design by Alexey Pajitnov. Tetris");
        do Output.moveCursor(17, 1);
        do Output.printString("Logo Design by Roger Dean. All Rights Reserved.");

        do Output.moveCursor(20, 16);
        do Output.printString("Press [SPACE] to start the game!");
        return;
    }

    method void drawBackground() {
        do Screen.drawRectangle(left - 1, top - 1, left + 121, top + 201);
        return;
    }

    /** Play a round of Tetris.
     *
     * Continue to run the game until the user either quits voluntarily by
     * pressing 'Q', or triggers a game over condition.
     *
     * In either case, return the final score achieved in the round.
     */
    method int play() {
        var int score;
        var boolean continue;

        do Screen.clearScreen();
        do drawBackground();
        let queue = Queue.new();
        let matrix = Matrix.new(width, height);
        let continue = true;

        while (continue) {
            let continue = step();
            do Sys.wait(500);
        }

        do queue.dispose();
        do matrix.dispose();
        return score;
    }

    /** Execute one game time step.
     * 
     * Return true if the game is still in play, or false if it's over.
     */
    method boolean step() {
        var int type;
        var Array piece;

        let type = matrix.getActiveType();
        if (type = 0) {
            let type = 7;
            //let type = queue.pop();
            if (~matrix.addPiece(type)) {
                return false;
            }
        }
        let piece = matrix.getActiveCells();
        do eraseBlock(piece[0]);
        do eraseBlock(piece[1]);
        do eraseBlock(piece[2]);
        do eraseBlock(piece[3]);

        do matrix.drop();
        let piece = matrix.getActiveCells();

        do drawBlock(piece[0], type);
        do drawBlock(piece[1], type);
        do drawBlock(piece[2], type);
        do drawBlock(piece[3], type);

        return true;
    }

    method void eraseBlock(int location) {
        var int x, y, rows;
        let rows = location / width;
        if (rows > maxRow) {
            return;
        }
        let y = top + ((maxRow - rows) * 12);
        let x = left + ((location - (rows * width)) * 12);
        do Block.erase(x, y);
        return;
    }

    method void drawBlock(int location, int type) {
        var int x, y, rows;
        let rows = location / width;
        if (rows > maxRow) {
            return;
        }
        let y = top + ((maxRow - rows) * 12);
        let x = left + ((location - (rows * width)) * 12);
        do Block.draw(x, y, type);
        return;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
}
